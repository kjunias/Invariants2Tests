package search;

public class BinarySearch {

	/*@
	@ public normal_behavior // Generated by Daikon
	@ requires sortedValues != null;
	@ requires daikon.Quant.eltsGTE(sortedValues, 0);
	@ requires daikon.Quant.eltwiseLT(sortedValues);
	@ requires daikon.Quant.size(sortedValues) == 0 || daikon.Quant.size(sortedValues) == 9 || daikon.Quant.size(sortedValues) == 10;
	@ ensures daikon.Quant.pairwiseEqual(sortedValues, \old(sortedValues));
	@ ensures (\result == false)  ==>  (\old(daikon.Quant.size(sortedValues)) == 0 || \old(daikon.Quant.size(sortedValues)) == 9 || \old(daikon.Quant.size(sortedValues)) == 10);
	@ ensures (\result == true)  ==>  (\old(daikon.Quant.size(sortedValues)) == 9);
	@ ensures (\result == true)  ==>  (daikon.Quant.memberOf(\old(value) , sortedValues ));
	@ ensures daikon.Quant.eltsGTE(sortedValues, 0);
	@ ensures daikon.Quant.eltwiseLT(sortedValues);
	@*/
	public boolean find(int[] sortedValues, int value) {
		return search(sortedValues, value, 0, sortedValues.length - 1);
	}

	/*@
	@ private normal_behavior // Generated by Daikon
	@ requires sorted != null;
	@ requires daikon.Quant.eltsGTE(sorted, 0);
	@ requires daikon.Quant.eltwiseLT(sorted);
	@ requires value >= -1;
	@ requires leftIndex >= 0;
	@ requires daikon.Quant.size(sorted) == 0 || daikon.Quant.size(sorted) == 9 || daikon.Quant.size(sorted) == 10;
	@ requires daikon.Quant.size(sorted)-1 != 0;
	@ requires leftIndex <= daikon.Quant.size(sorted);
	@ requires rightIndex <= daikon.Quant.size(sorted)-1;
	@ ensures daikon.Quant.pairwiseEqual(sorted, \old(sorted));
	@ ensures (\result == false)  ==>  (\old(daikon.Quant.size(sorted)) == 0 || \old(daikon.Quant.size(sorted)) == 9 || \old(daikon.Quant.size(sorted)) == 10);
	@ ensures (\result == true)  ==>  (\old(leftIndex) <= \old(rightIndex));
	@ ensures (\result == true)  ==>  (\old(leftIndex) <= daikon.Quant.size(sorted)-1);
	@ ensures (\result == true)  ==>  (\old(daikon.Quant.size(sorted)) == 9);
	@ ensures (\result == true)  ==>  (\old(daikon.Quant.getElement_int(sorted, leftIndex)) <= \old(daikon.Quant.getElement_int(sorted, rightIndex)));
	@ ensures (\result == true)  ==>  (\old(value) <= \old(daikon.Quant.getElement_int(sorted, rightIndex)));
	@ ensures (\result == true)  ==>  (\old(value) <= daikon.Quant.getElement_int(sorted, \old(rightIndex)));
	@ ensures (\result == true)  ==>  (\old(value) <= daikon.Quant.getElement_int(sorted, rightIndex));
	@ ensures (\result == true)  ==>  (\old(value) >= 0);
	@ ensures (\result == true)  ==>  (\old(value) >= \old(daikon.Quant.getElement_int(sorted, leftIndex)));
	@ ensures (\result == true)  ==>  (\old(value) >= daikon.Quant.getElement_int(sorted, leftIndex));
	@ ensures (\result == true)  ==>  (\old(value) >= daikon.Quant.getElement_int(sorted, \old(leftIndex)));
	@ ensures (\result == true)  ==>  (daikon.Quant.memberOf(\old(value) , sorted ));
	@ ensures (\result == true)  ==>  (daikon.Quant.getElement_int(sorted, leftIndex) <= \old(daikon.Quant.getElement_int(sorted, rightIndex)));
	@ ensures (\result == true)  ==>  (daikon.Quant.getElement_int(sorted, leftIndex) <= daikon.Quant.getElement_int(sorted, \old(rightIndex)));
	@ ensures (\result == true)  ==>  (daikon.Quant.getElement_int(sorted, leftIndex) <= daikon.Quant.getElement_int(sorted, rightIndex));
	@ ensures (\result == true)  ==>  (daikon.Quant.getElement_int(sorted, \old(leftIndex)) <= \old(daikon.Quant.getElement_int(sorted, rightIndex)));
	@ ensures (\result == true)  ==>  (daikon.Quant.getElement_int(sorted, \old(leftIndex)) <= daikon.Quant.getElement_int(sorted, \old(rightIndex)));
	@ ensures (\result == true)  ==>  (daikon.Quant.getElement_int(sorted, \old(rightIndex)) >= \old(daikon.Quant.getElement_int(sorted, leftIndex)));
	@ ensures (\result == true)  ==>  (daikon.Quant.getElement_int(sorted, rightIndex) >= \old(daikon.Quant.getElement_int(sorted, leftIndex)));
	@ ensures (\result == true)  ==>  (daikon.Quant.getElement_int(sorted, rightIndex) >= daikon.Quant.getElement_int(sorted, \old(leftIndex)));
	@ ensures daikon.Quant.eltsGTE(sorted, 0);
	@ ensures daikon.Quant.eltwiseLT(sorted);
	@ ensures daikon.Quant.size(sorted)-1 != 0;
	@ ensures \old(rightIndex) <= daikon.Quant.size(sorted)-1;
	@*/
	private boolean search(int[] sorted, int value, int leftIndex, int rightIndex) {

		// 1. index check
		if (leftIndex > rightIndex) {
			return false;
		}

		// 2. middle index
		int middle = (rightIndex + leftIndex) / 2;

		// 3. recursive invoke
		if (sorted[middle] > value) {
			return search(sorted, value, leftIndex, middle - 1);
		} else if (sorted[middle] < value) {
			return search(sorted, value, middle + 1, rightIndex);
		} else {
			return true;
		}
	}
}
